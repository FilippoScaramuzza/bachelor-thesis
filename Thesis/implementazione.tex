\chapter{Sviluppo ed Utilizzo}
\label{chapter:implementazione}

\section[Sistema Realizzato per Simulazioni ed Analisi]{Sistema Realizzato per Simulazioni ed\\ Analisi}
\label{section:sistema_analisi}

Al fine di valutare le prestazioni degli scenari di Fog Computing, descritti al capitolo \ref{chapter:architettura}, è stato implementato un sistema di simulazione che ne permette in una prima fase la definizione in ogni suo aspetto (topologia, applicazioni, servizi, richieste, ecc...) e, successivamente, l'analisi dei principali aspetti utili alla comprensione dello scenario, come il successo del \textit{service placement} e delle richieste di servizi da parte dei vari nodi della rete.

La definizione e l'esecuzione della simulazione seguono il diagramma di flusso mostrato in Figura \ref{fig:sim_flow_diagram}. Come accennato è possibile eseguire due principali tipologie di analisi:
\begin{enumerate}
	\item \textbf{Analisi del service placement}. È possibile analizzare l'andamento del service placement al variare di specifici parametri di definizione dello scenario, specificando il numero di iterazioni e quali di questi devono variare ad ogni esecuzione.
	\item \textbf{Analisi della simulazione}. Una volta definito e simulato uno specifico scenario, è possibile ottenere un'analisi sul soddisfacimento delle richieste da parte dei nodi dei vari servizi offerti dalla rete, con e senza \textit{failure control} dei nodi/servizi.
\end{enumerate}


\begin{figure}[!ht]
  \includegraphics[width=14cm]{images/sim_flow_diagram}
  \centering
  \caption{Diagramma di flusso del sistema di simulazione.}
  \label{fig:sim_flow_diagram}
\end{figure}

\subsection{Utilizzo del Software Realizzato}

Entrambe le tipologie di simulazione, prevedono alcuni passaggi obbligati. Nella fase di inizializzazione del primo stadio delle simulazioni è presente la configurazione dell'esperimento. Questa può essere eseguita tramite opportune modifiche al file \texttt{experimentConfiguration.py}.

\subsubsection{Configurazione della Topologia}

La topologia, generata dinamicamente in fase di inizializzazione, può essere configurata con i seguenti parametri:
\begin{itemize}
	\item \texttt{IOT\_DEVUCES\_NUM}: il numero di device IoT che la rete deve supportare.
	\item \texttt{NETWORK\_LEVELS\_NUM}: il numero di livelli dello scenario Fog. Questo valore comprende il livello IoT, il livello Gateway, i livelli Fog e il livello Cloud.
	\item \texttt{REDUCTION\_FACTOR\_1}: il fattore di riduzione del numero di nodi dal livello IoT al livello Gateway.
	\item \texttt{REDUCTION\_FACTOR\_2}: il fattore di riduzione del numero di nodi dal livello FOG $(i)$ al livello FOG $(i+1)$.
	\item \texttt{LINK\_GENERATION\_PROBABILITY\_FOG0}: probabilità di generazione di collegamenti tra i nodi del livello FOG $(0)$.
	\item \texttt{HUB\_GENERATION\_PROBABILITY}: probabilità di generazione di nodi ``hub" (con un elevato \textit{degree}) all'interno dei livelli FOG. 
	\item \texttt{MIN\_CONN\_TO\_UPPER\_LEVEL}: numero minimo di connessioni da un livello FOG a quelli superiori.
	\item \texttt{MAX\_CONN\_TO\_UPPER\_LEVEL}: numero massimo di connessioni da un livello FOG a quelli superiori.
\end{itemize}

\subsubsection{Configurazione delle Caratteristiche di Rete}

È possibile, modificando gli opportuni parametri, agire sulle caratteristiche dei singoli nodi appartenenti alla topologia, come la loro memoria (\textit{RAM}) o il numero di istruzioni per unità di tempo (\textit{IPT}). La prima è configurabile tramite parametri nella forma \texttt{FUNC\_NODE\_RAM\_LEVEL}, dove \texttt{LEVEL} può essere \texttt{FOGi} oppure \texttt{CLOUD}. Allo stesso modo è possibile configurare le istruzioni per unità di tempo, tramite i parametri nella forma \texttt{FUNC\_NODE\_IPT\_LEVEL}. Questi parametri e tutti gli altri che hanno il prefisso \texttt{FUNC}, possono essere inizializzati con una stringa contenente una determinata distribuzione, ad esempio:
\begin{lstlisting}[language=python]
	self.FUNC_NODE_IPT_FOG2 = "random.randrange(400, 900)"
\end{lstlisting}

Allo stesso modo è possibile agire sulle caratteristiche dei collegamenti di rete, ovvero la loro larghezza di banda (\textit{BW}) e la velocità di propagazione del segnale (\textit{PR}). Per entrambe i parametri di configurazione sono nella forma:
\begin{itemize}
	\item \texttt{FUNC\_EDGE\_[PR o BW]\_SAME\_LEVEL}: il valore viene assegnato a collegamenti tra nodi che appartengono allo stesso livello.
	\item \texttt{FUNC\_EDGE\_[PR o BW]\_ADJ\_LEVEL}: il valore viene assegnato a collegamenti tra nodi che appartengono a livelli adiacenti.
	\item \texttt{FUNC\_EDGE\_[PR o BW]\_NON\_ADJ\_LEVEL\_1}: il valore viene assegnato a collegamenti tra nodi che sono separati da un solo altro livello oltre a quelli di appartenenza.
	\item \texttt{FUNC\_EDGE\_[PR o BW]\_NON\_ADJ\_LEVEL\_2}: il valore viene assegnato a collegamenti tra nodi che sono separati da più di un livello oltre a quelli di appartenenza.
\end{itemize}

\subsubsection{Configurazione delle Applicazioni e delle Richieste}

Tramite opportuni parametri, è possibile configurare la generazione di applicazioni e dei servizi ad esse collegati. Inoltre è possibile specificare il numero di richieste che devono essere effettuate dagli utenti (i dispositivi IoT o i nodi Gateway). 
\begin{itemize}
	\item \texttt{FUNC\_APP\_GENERATION}. Le applicazioni generate sono dei \textit{grafi diretti aciclici}. Un esempio di configurazione tramite questo parametro è esposto di seguito.
		\begin{lstlisting}[language=python]
		self.FUNC_APP_GENERATION = "nx.gn_graph(random.randint(2,7))"
		\end{lstlisting}
		I valori 2 e 7, indicano il range del possibile numero di servizi per quella specifica applicazione.
	\item \texttt{FUNC\_APP\_DEADLINES}: distribuzione delle \textit{deadline} delle applicazioni. Questo specifica la priorità di una determinata applicazione in fase di esecuzione.
	\item \texttt{FUNC\_SERVICE\_RESOURCES}: distribuzione delle risorse richieste dai servizi.
	\item \texttt{FUNC\_SERVICEMESSAGESIZE}: distribuzione delle dimensioni dei messaggi scambiati tra i servizi.
	\item \texttt{FUNC\_REQUESTPROB}: distribuzione di probabilità di richieste per le applicazioni.
	\item \texttt{FUNC\_USERREQRAT}: distribuzione del numero di richieste emesse dagli utenti per le applicazioni.
\end{itemize}

\subsubsection{Analisi sull'Algoritmo di Placement}
Il software è stato realizzato in modo che fosse possibile valutare l'algoritmo di \textit{placement} utilizzato, operando sui parametri del file \texttt{runExperiment.py}. In modo automatico, vengono generati 
		$$\frac{\text{\texttt{VALUE\_TO}} - \text{\texttt{VALUE\_FROM}}}{\text{\texttt{STEP}}}$$
scenari al variare del parametro \texttt{PARAM\_TO\_CHANGE}.

\section{Implementazione del Simulatore}

In questo paragrafo verranno approfonditi i singoli aspetti che compongono il processo esposto al Paragrafo \ref{section:sistema_analisi}, nonché il loro utilizzo per la definizione e l'esecuzione delle simulazioni.

\subsection{Algoritmo di Service Placement}

Per ottenere il massimo beneficio dall'implementazione di un'architettura Fog, è necessario un efficace algoritmo di \textit{service placement}. In generale questi algoritmi sono improntati a massimizzare il \textit{Quality of Service}\footnote{Con \textit{Quality of Service} si intende l'insieme dei valori che indicano la qualità del servizio offerto dalla rete, in termini di throughput, gestione degli errori, gestione dei ritardi e utilizzo della banda.} (QoS) o il bilanciamento del carico, oppure a minimizzare il consumo di energia, la latenza o il costo della comunicazione.

In questo lavoro di Tesi, l'algoritmo implementato\footnote{In: \texttt{placeService.py}} è fondato su due aspetti principali: preservare la \textit{privacy} dei dati scambiati tra i servizi e far si che le applicazioni siano disponibili per gli utenti il più velocemente possibile. L'algoritmo utilizza un approccio \textit{Greedy}\footnote{L'approccio \textit{Greedy}, come paradigma negli algoritmi, indica la costruzione della soluzione ottima scegliendo, ad ogni iterazione, la via che offre il maggiore vantaggio in quello specifico stadio. } valutando i diversi aspetti dei servizi, come privacy, risorse necessarie e \textit{deadlines} delle applicazioni. La privacy dei servizi è relativa al loro livello di piazzamento: con livelli di privacy crescenti (la sensibilità dei dati), i servizi potranno essere piazzati solo in livelli via via più bassi, ovvero più vicino al livello IoT. La tendenza dell'algoritmo è quella di allocare le applicazioni il più vicino possibile al livello IoT, così da minimizzare la latenza.

Il primo passo che viene compiuto è l'ordinamento delle applicazioni secondo un ordine crescente sulla base del livello di privacy dei servizi che la compongono. In particolare viene utilizzato il seguente approccio:
\begin{equation*}  
	\begin{array}{c}

\displaystyle \operatorname{privacy}(APP_x) \leq \operatorname{privacy}(APP_y)\\
\text{se e soltanto se}\\
\displaystyle \min_{S_u \in APP_x} \operatorname{privacy}(S_u) \leq \min_{S_v \in APP_y} \operatorname{privacy}(S_v)
 	\end{array}
\end{equation*}
dove $S_u$ e $S_v$ sono i servizi delle singole applicazioni. Nel caso particolare in cui due applicazioni abbiamo lo stesso valore di privacy, allora verranno ordinate secondo la loro \textit{deadline}, in ordine crescente.

Una volta eseguito l'ordinamento delle applicazioni, l'algoritmo di placement comincia ad allocare i servizi iniziando dalla prima applicazione della lista. L'algoritmo tende a posizionare i servizi nei primi nodi disponibili cominciando da quelli più vicini agli utenti (livello IoT). Nel caso di insufficienza di risorse e se il livello di privacy lo permette, i servizi vengono allocati nel Cloud. Una applicazione viene considerata ``allocata" se e solo se lo sono tutti i suoi servizi, altrimenti viene scartata.

Le applicazioni che l'algoritmo di \textit{service placement} tenta di allocare, sono generate nella configurazione dell'esperimento.

\subsection{Experiment Configuration}

La configurazione dell'esperimento\footnote{In: \texttt{config/experimentConfiguration.py}} gestisce la generazione della topologia di rete, delle applicazioni e degli utenti, ovvero i dispositivi che generano le richieste dei servizi.

\subsubsection{Generazione della Topologia}

Come accennato nel capitolo \ref{chapter:architettura}, il simulatore \textit{YAFS} utilizza \textit{NetworkX} come base per l'analisi e l'utilizzo dei grafi. La stessa libreria \textit{python} è stata dunque utilizzata anche per la generazione della rete.

Per semplicità è stato introdotto un livello di \textit{gateway}, il cui scopo è quello di fungere da intermediario da i dispositivi IoT e la rete. I nodi di questo livello sono generati come mostrato di seguito.

\begin{lstlisting}[language=python]
H.add_nodes_from([(i, {"level[z]": level}) for i in range(iot_nodes // 5)])
\end{lstlisting}

La divisione del numero di nodi IoT (\texttt{iot\_nodes}) per 5, indica che il numero dei \textit{gateway} accennati sopra, saranno $1\backslash 5$ del numero di nodi IoT.

Per i livelli successivi viene utilizzato, come descritto nel paragrafo \ref{section:interconnesione_livelli}, il modello \textit{Watts-Strogatz}:
\begin{lstlisting}[language=python]
# Number of nodes of upper levels
new_nodes = iot_nodes // (fogi_reduction_factor ** (level-1)) if iot_nodes // (fogi_reduction_factor**(level-1)) >= 2 else 2
                
# Small-World graph generation for FOG levels greater than 0 (e.g provincial fog nodes)
H = nx.watts_strogatz_graph(int(new_nodes), 2, hub_prob)
\end{lstlisting}

% Andare avanti con la spiegazione sulla generazione delle varie cose.




